# ts-to-rs

A TypeScript to Rust type converter for bidirectional JSON serialization.

## Overview

`ts-to-rs` deeply inspects TypeScript types using `ts-morph` and generates corresponding Rust types with proper `serde` attributes for seamless JSON serialization/deserialization between TypeScript and Rust.

## Installation

```bash
bun add ts-to-rs
```

## Usage

### CLI

```bash
# Convert all exported types from a file
ts-to-rs -i ./src/types.ts -o ./generated/types.rs

# Convert specific types
ts-to-rs -i ./src/types.ts -t User,Post,Comment -o ./generated/types.rs

# Output to stdout
ts-to-rs -i ./src/types.ts -t User

# Custom type mappings
ts-to-rs -i ./src/types.ts -m "MyDate:chrono::DateTime<Utc>" -o ./types.rs

# Disable camelCase renaming
ts-to-rs -i ./src/types.ts --no-camel-case -o ./types.rs
```

### CLI Options

| Option | Description |
|--------|-------------|
| `-i, --input <path>` | Path to the TypeScript entry file (required) |
| `-o, --output <path>` | Output path for the generated Rust file |
| `-t, --types <names>` | Comma-separated list of type names to convert |
| `--no-serde` | Disable serde attribute generation |
| `--no-camel-case` | Disable camelCase renaming in serde |
| `--no-skip-none` | Disable skip_serializing_if for Option fields |
| `-m, --mapping <mappings>` | Custom type mappings (TypeScriptName:RustName,...) |

### Programmatic API

```typescript
import { convert, resolveTypes, generateRust } from 'ts-to-rs';

// Full conversion
const result = await convert({
  entryFile: './src/types.ts',
  typeNames: ['User', 'Post'],
  outputPath: './generated/types.rs',
  generateSerdeAttributes: true,
  useCamelCase: true,
  skipSerializingNone: true,
});

console.log(result.rustCode);
console.log('Converted types:', result.convertedTypes);
console.log('Warnings:', result.warnings);

// Just resolve types (for inspection or custom processing)
const types = resolveTypes({
  entryFile: './src/types.ts',
  typeNames: ['User'],
});

// Generate Rust from pre-resolved types
const rustResult = generateRust(types, {
  useCamelCase: true,
});
```

## Type Mappings

### Primitive Types

| TypeScript | Rust |
|------------|------|
| `string` | `String` |
| `number` | `f64` |
| `boolean` | `bool` |
| `undefined` | `Option<T>` |
| `null` | `Option<T>` |
| `any` | `serde_json::Value` |
| `unknown` | `serde_json::Value` |

### Complex Types

| TypeScript | Rust |
|------------|------|
| `Array<T>` / `T[]` | `Vec<T>` |
| `ReadonlyArray<T>` | `Vec<T>` |
| `[T, U, V]` (tuple) | `(T, U, V)` |
| `Record<string, T>` | `HashMap<String, T>` |
| `Map<K, V>` | `HashMap<K, V>` |
| `Set<T>` | `HashSet<T>` |
| `Date` | `String` (ISO 8601) |

### Object & Interface Types

| TypeScript | Rust |
|------------|------|
| `interface` | `struct` with `#[derive(Serialize, Deserialize)]` |
| `type` (object) | `struct` with `#[derive(Serialize, Deserialize)]` |
| Optional property (`field?: T`) | `Option<T>` with `#[serde(skip_serializing_if = "Option::is_none")]` |

### Enum Types

| TypeScript | Rust |
|------------|------|
| String enum | `enum` with `#[serde(rename = "...")]` variants |
| Numeric enum | `enum` with `#[repr(u32)]` |
| String literal union | `enum` with string variants |
| Discriminated union | Tagged `enum` variants |

## Examples

### Input TypeScript

```typescript
// types.ts
export interface User {
  id: string;
  name: string;
  email: string;
  age?: number;
  roles: string[];
  metadata: Record<string, any>;
  createdAt: Date;
}

export enum Status {
  Active = "active",
  Inactive = "inactive",
}

export type Direction = "north" | "south" | "east" | "west";

export type Result =
  | { success: true; data: string }
  | { success: false; error: string };
```

### Generated Rust

```rust
// This file is auto-generated by ts-to-rs. Do not edit manually.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use serde_json::Value;

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct User {
    pub id: String,
    pub name: String,
    pub email: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub age: Option<f64>,
    pub roles: Vec<String>,
    pub metadata: HashMap<String, Value>,
    pub created_at: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Status {
    #[serde(rename = "active")]
    Active,
    #[serde(rename = "inactive")]
    Inactive,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Direction {
    #[serde(rename = "north")]
    North,
    #[serde(rename = "south")]
    South,
    #[serde(rename = "east")]
    East,
    #[serde(rename = "west")]
    West,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Result {
    Success { data: String },
    Error { error: String },
}
```

## Error Handling

The converter throws `TypeConversionError` when it encounters a type that cannot be converted:

```typescript
import { convert, TypeConversionError } from 'ts-to-rs';

try {
  await convert({
    entryFile: './types.ts',
    typeNames: ['InvalidType'],
  });
} catch (error) {
  if (error instanceof TypeConversionError) {
    console.error(`Failed to convert ${error.typeName}: ${error.reason}`);
    console.error(`Location: ${error.sourceFile}:${error.line}`);
  }
}
```

### Unsupported Types

The following TypeScript types cannot be converted and will throw an error:

- `Promise<T>` - Async types cannot be serialized
- `Function` - Functions cannot be serialized
- Circular type references (handled gracefully with cycle detection)

## License

MIT