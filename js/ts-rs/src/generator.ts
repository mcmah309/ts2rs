/**
 * Rust code generator from resolved TypeScript types
 */

import type {
  ResolvedType,
  CollectedType,
  StructType,
  EnumType,
  UnionType,
  ConversionOptions,
  ConversionResult,
  StructField,
  TypeAliasType,
} from "./types";
import { TypeConversionError } from "./types";

/**
 * Generates Rust code from collected TypeScript types
 */
export class RustGenerator {
  private options: ConversionOptions;
  private generatedTypes: Set<string> = new Set();
  private warnings: string[] = [];

  constructor(options: ConversionOptions) {
    this.options = options;
  }

  /**
   * Generate Rust code from collected types
   */
  generate(collectedTypes: CollectedType[]): ConversionResult {
    const lines: string[] = [];

    // Add header comment
    lines.push("// This file is auto-generated by ts-to-rs. Do not edit manually.");
    lines.push("// Source: " + this.options.entryFile);
    lines.push("");

    // Add necessary imports
    lines.push("use serde::{Deserialize, Serialize};");

    // Check if we need HashMap or HashSet
    const needsHashMap = this.checkNeedsHashMap(collectedTypes);
    const needsHashSet = this.checkNeedsHashSet(collectedTypes);
    const needsSerdeJson = this.checkNeedsSerdeJson(collectedTypes);

    if (needsHashMap || needsHashSet) {
      const collections: string[] = [];
      if (needsHashMap) collections.push("HashMap");
      if (needsHashSet) collections.push("HashSet");
      lines.push(`use std::collections::{${collections.join(", ")}};`);
    }

    if (needsSerdeJson) {
      lines.push("use serde_json::Value;");
    }

    lines.push("");

    // Generate types in dependency order
    const sortedTypes = this.sortByDependency(collectedTypes);

    for (const collected of sortedTypes) {
      if (this.generatedTypes.has(collected.name)) {
        continue;
      }

      const typeCode = this.generateType(collected);
      if (typeCode) {
        lines.push(typeCode);
        lines.push("");
        this.generatedTypes.add(collected.name);
      }
    }

    return {
      rustCode: lines.join("\n"),
      convertedTypes: Array.from(this.generatedTypes),
      warnings: this.warnings,
    };
  }

  private checkNeedsHashMap(types: CollectedType[]): boolean {
    return types.some((t) => this.typeUsesHashMap(t.type));
  }

  private checkNeedsHashSet(types: CollectedType[]): boolean {
    return types.some((t) => this.typeUsesHashSet(t.type));
  }

  private checkNeedsSerdeJson(types: CollectedType[]): boolean {
    return types.some((t) => this.typeUsesSerdeJson(t.type));
  }

  private typeUsesHashMap(type: ResolvedType): boolean {
    switch (type.kind) {
      case "record":
      case "map":
        return true;
      case "struct":
        return type.fields.some((f) => this.typeUsesHashMap(f.type));
      case "array":
        return this.typeUsesHashMap(type.elementType);
      case "option":
        return this.typeUsesHashMap(type.innerType);
      case "tuple":
        return type.elements.some((e) => this.typeUsesHashMap(e));
      case "union":
        return type.variants.some((v) => v.type && this.typeUsesHashMap(v.type));
      default:
        return false;
    }
  }

  private typeUsesHashSet(type: ResolvedType): boolean {
    switch (type.kind) {
      case "set":
        return true;
      case "struct":
        return type.fields.some((f) => this.typeUsesHashSet(f.type));
      case "array":
        return this.typeUsesHashSet(type.elementType);
      case "option":
        return this.typeUsesHashSet(type.innerType);
      case "tuple":
        return type.elements.some((e) => this.typeUsesHashSet(e));
      case "union":
        return type.variants.some((v) => v.type && this.typeUsesHashSet(v.type));
      default:
        return false;
    }
  }

  private typeUsesSerdeJson(type: ResolvedType): boolean {
    switch (type.kind) {
      case "json_value":
        return true;
      case "struct":
        return type.fields.some((f) => this.typeUsesSerdeJson(f.type));
      case "array":
        return this.typeUsesSerdeJson(type.elementType);
      case "option":
        return this.typeUsesSerdeJson(type.innerType);
      case "tuple":
        return type.elements.some((e) => this.typeUsesSerdeJson(e));
      case "union":
        return type.variants.some((v) => v.type && this.typeUsesSerdeJson(v.type));
      case "record":
      case "map":
        return this.typeUsesSerdeJson(type.valueType);
      case "set":
        return this.typeUsesSerdeJson(type.elementType);
      default:
        return false;
    }
  }

  private sortByDependency(types: CollectedType[]): CollectedType[] {
    // Simple topological sort based on type references
    const typeMap = new Map(types.map((t) => [t.name, t]));
    const visited = new Set<string>();
    const result: CollectedType[] = [];

    const visit = (name: string) => {
      if (visited.has(name)) return;
      visited.add(name);

      const type = typeMap.get(name);
      if (!type) return;

      // Get dependencies
      const deps = this.getTypeDependencies(type.type);
      for (const dep of deps) {
        if (typeMap.has(dep)) {
          visit(dep);
        }
      }

      result.push(type);
    };

    for (const type of types) {
      visit(type.name);
    }

    return result;
  }

  private getTypeDependencies(type: ResolvedType): string[] {
    const deps: string[] = [];

    const collectDeps = (t: ResolvedType) => {
      switch (t.kind) {
        case "struct":
          if (t.name && t.fields.length === 0) {
            deps.push(t.name);
          }
          t.fields.forEach((f) => collectDeps(f.type));
          break;
        case "array":
          collectDeps(t.elementType);
          break;
        case "option":
          collectDeps(t.innerType);
          break;
        case "tuple":
          t.elements.forEach(collectDeps);
          break;
        case "record":
        case "map":
          collectDeps(t.keyType);
          collectDeps(t.valueType);
          break;
        case "set":
          collectDeps(t.elementType);
          break;
        case "union":
          t.variants.forEach((v) => v.type && collectDeps(v.type));
          break;
      }
    };

    collectDeps(type);
    return deps;
  }

  private generateType(collected: CollectedType): string {
    const { type } = collected;

    switch (type.kind) {
      case "struct":
        return this.generateStruct(type);
      case "enum":
        return this.generateEnum(type);
      case "union":
        return this.generateUnion(type);
      case "type_alias":
        return this.generateTypeAlias(type);
      default: {
        const exhaustiveCheck: never = type;
        throw new TypeConversionError(
          collected.name,
          `Cannot generate top-level type of kind '${(exhaustiveCheck as any).kind}'`,
          collected.sourceFile,
        );
      }
    }
  }

  private generateStruct(type: StructType): string {
    const lines: string[] = [];

    // Add documentation
    if (type.documentation) {
      lines.push(this.formatDocComment(type.documentation));
    }

    // Add derive macros
    lines.push("#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]");

    lines.push('#[serde(rename_all = "camelCase")]');

    // Generate struct definition
    const typeParams = type.typeParameters ? `<${type.typeParameters.join(", ")}>` : "";
    lines.push(`pub struct ${type.name}${typeParams} {`);

    for (const field of type.fields) {
      const fieldLines = this.generateStructField(field);
      lines.push(...fieldLines.map((l) => "    " + l));
    }

    lines.push("}");

    return lines.join("\n");
  }

  private generateStructField(field: StructField): string[] {
    const lines: string[] = [];

    // Add documentation
    if (field.documentation) {
      lines.push(this.formatDocComment(field.documentation));
    }

    // Add serde attributes for optional fields
    if (
      field.optional &&
      field.type.kind === "option"
    ) {
      lines.push('#[serde(skip_serializing_if = "Option::is_none")]');
    }

    // Handle field name conversion
    const rustFieldName = this.toSnakeCase(field.name);

    if (rustFieldName !== field.name) {
      lines.push(`#[serde(rename = "${field.name}")]`);
    }

    const rustType = this.resolvedTypeToRust(field.type);
    lines.push(`pub ${rustFieldName}: ${rustType},`);

    return lines;
  }

  private generateEnum(type: EnumType): string {
    const lines: string[] = [];

    // Add documentation
    if (type.documentation) {
      lines.push(this.formatDocComment(type.documentation));
    }

    // Add derive macros
    lines.push("#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]");

    // Note: We don't use #[repr(u32)] for numeric enums because serde doesn't 
    // support automatic numeric serialization without the serde_repr crate.
    // Instead, we serialize all enums as strings for consistency.

    lines.push(`pub enum ${type.name} {`);

    for (const variant of type.variants) {
      if (variant.documentation) {
        lines.push("    " + this.formatDocComment(variant.documentation));
      }

      // For both string and numeric enums, use string-based serialization
      if (typeof variant.value === "string") {
        lines.push(`    #[serde(rename = "${variant.value}")]`);
        lines.push(`    ${variant.name},`);
      } else if (typeof variant.value === "number") {
        // Serialize numeric enums using their numeric value as a string
        lines.push(`    #[serde(rename = "${variant.value}")]`);
        lines.push(`    ${variant.name},`);
      } else {
        lines.push(`    ${variant.name},`);
      }
    }

    lines.push("}");

    return lines.join("\n");
  }

  private generateUnion(type: UnionType): string {
    const lines: string[] = [];

    // Add documentation
    if (type.documentation) {
      lines.push(this.formatDocComment(type.documentation));
    }

    // Add derive macros
    lines.push("#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]");

    // Use tagged representation only if we have a string discriminator
    // (serde's tag attribute only works with strings)
    const hasStringDiscriminator = type.discriminator &&
      type.variants.every(v => typeof v.discriminatorValue === "string");

    if (hasStringDiscriminator) {
      lines.push(`#[serde(tag = "${type.discriminator}")]`);
    } else {
      lines.push("#[serde(untagged)]");
    }

    lines.push(`pub enum ${type.name} {`);

    for (const variant of type.variants) {
      if (variant.documentation) {
        lines.push("    " + this.formatDocComment(variant.documentation));
      }

      // Add rename attribute for discriminated unions
      if (type.discriminator && variant.discriminatorValue) {
        lines.push(`    #[serde(rename = "${variant.discriminatorValue}")]`);
      }

      if (variant.type === null) {
        lines.push(`    ${variant.name},`);
      } else if (variant.type.kind === "struct" && variant.type.fields.length > 0) {
        // Inline struct variant
        lines.push(`    ${variant.name} {`);
        for (const field of variant.type.fields) {
          const fieldLines = this.generateUnionVariantField(field);
          lines.push(...fieldLines.map((l) => "        " + l));
        }
        lines.push("    },");
      } else {
        const rustType = this.resolvedTypeToRust(variant.type);
        lines.push(`    ${variant.name}(${rustType}),`);
      }
    }

    lines.push("}");

    return lines.join("\n");
  }

  private generateTypeAlias(type: TypeAliasType): string {
    const lines: string[] = [];

    // Add documentation
    if (type.documentation) {
      lines.push(this.formatDocComment(type.documentation));
    }

    const rustType = this.resolvedTypeToRust(type.aliasedType);
    lines.push(`pub type ${type.name} = ${rustType};`);

    return lines.join("\n");
  }

  private generateUnionVariantField(field: StructField): string[] {
    const lines: string[] = [];

    // Add documentation
    if (field.documentation) {
      lines.push(this.formatDocComment(field.documentation));
    }

    // Add serde attributes for optional fields
    if (
      field.optional &&
      field.type.kind === "option"
    ) {
      lines.push('#[serde(skip_serializing_if = "Option::is_none")]');
    }

    const rustFieldName = this.toSnakeCase(field.name);

    if (rustFieldName !== field.name) {
      lines.push(`#[serde(rename = "${field.name}")]`);
    }

    const rustType = this.resolvedTypeToRust(field.type);
    // Note: No 'pub' keyword for enum variant fields
    lines.push(`${rustFieldName}: ${rustType},`);

    return lines;
  }

  private resolvedTypeToRust(type: ResolvedType): string {
    // Check custom type mappings first
    if (this.options.customTypeMappings) {
      if (type.kind === "struct" && type.name) {
        const customMapping = this.options.customTypeMappings[type.name];
        if (customMapping) {
          return customMapping;
        }
      }
    }

    switch (type.kind) {
      case "primitive":
        return this.primitiveToRust(type.type);

      case "array":
        return `Vec<${this.resolvedTypeToRust(type.elementType)}>`;

      case "tuple":
        const elements = type.elements.map((e) => this.resolvedTypeToRust(e));
        return `(${elements.join(", ")})`;

      case "record":
        return `HashMap<${this.resolvedTypeToRust(type.keyType)}, ${this.resolvedTypeToRust(type.valueType)}>`;

      case "map":
        return `HashMap<${this.resolvedTypeToRust(type.keyType)}, ${this.resolvedTypeToRust(type.valueType)}>`;

      case "set":
        return `HashSet<${this.resolvedTypeToRust(type.elementType)}>`;

      case "option":
        return `Option<${this.resolvedTypeToRust(type.innerType)}>`;

      case "struct":
        if (type.name) {
          return type.name;
        }
        // Anonymous struct - should not happen at top level
        this.warnings.push("Anonymous struct encountered - using serde_json::Value");
        return "Value";

      case "enum":
        return type.name;

      case "union":
        return type.name;

      case "literal":
        // Literals in field positions should use their base type
        if (typeof type.value === "string") return "String";
        if (typeof type.value === "number") return "f64";
        if (typeof type.value === "boolean") return "bool";
        return "Value";

      case "json_value":
        return "Value";

      default:
        throw new TypeConversionError(
          "unknown",
          `Unknown type kind: ${(type as any).kind}`,
        );
    }
  }

  private primitiveToRust(primitive: string): string {
    switch (primitive) {
      case "string":
        return "String";
      case "number":
        return "f64";
      case "boolean":
        return "bool";
      case "null":
      case "undefined":
        return "()";
      default:
        throw new TypeConversionError(primitive, `Unknown primitive type: ${primitive}`);
    }
  }

  private toSnakeCase(str: string): string {
    return str
      .replace(/([A-Z])/g, "_$1")
      .toLowerCase()
      .replace(/^_/, "")
      .replace(/-/g, "_");
  }

  private formatDocComment(doc: string): string {
    const lines = doc.trim().split("\n");
    return lines.map((line) => `/// ${line}`).join("\n");
  }
}
